"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var child_process_1 = require("child_process");
var path = require("path");
var affected_apps_1 = require("./affected-apps");
var fs = require("fs");
var affected_apps_2 = require("@nrwl/schematics/src/command-line/affected-apps");
var fs_1 = require("fs");
function parseFiles(args) {
    var unnamed = [];
    var named = [];
    args.forEach(function (a) {
        if (a.startsWith('--') || a.startsWith('-')) {
            named.push(a);
        }
        else {
            unnamed.push(a);
        }
    });
    var dashDashFiles = named.filter(function (a) { return a.startsWith('--files='); })[0];
    if (dashDashFiles) {
        named.splice(named.indexOf(dashDashFiles), 1);
        return {
            files: parseDashDashFiles(dashDashFiles),
            rest: unnamed.concat(named)
        };
    }
    else if (unnamed.length >= 2) {
        return {
            files: getFilesFromShash(unnamed[0], unnamed[1]),
            rest: unnamed.slice(2).concat(named)
        };
    }
    else {
        throw new Error('Invalid options provided');
    }
}
exports.parseFiles = parseFiles;
function parseDashDashFiles(dashDashFiles) {
    var f = dashDashFiles.substring(8); // remove --files=
    if (f.startsWith('"') || f.startsWith("'")) {
        f = f.substring(1, f.length - 1);
    }
    return f.split(',').map(function (f) { return f.trim(); });
}
function getFilesFromShash(sha1, sha2) {
    return child_process_1.execSync("git diff --name-only " + sha1 + " " + sha2)
        .toString('utf-8')
        .split('\n')
        .map(function (a) { return a.trim(); })
        .filter(function (a) { return a.length > 0; });
}
function getProjectNodes(config) {
    return (config.apps ? config.apps : [])
        .filter(function (p) { return p.name !== '$workspaceRoot'; })
        .map(function (p) {
        return {
            name: p.name,
            root: p.root,
            type: p.root.startsWith('apps/') ? affected_apps_1.ProjectType.app : affected_apps_1.ProjectType.lib,
            tags: p.tags,
            files: allFilesInDir(path.dirname(p.root))
        };
    });
}
exports.getProjectNodes = getProjectNodes;
function getAffectedApps(touchedFiles) {
    var config = JSON.parse(fs.readFileSync('.angular-cli.json', 'utf-8'));
    var projects = getProjectNodes(config);
    if (!config.project.npmScope) {
        throw new Error(".angular-cli.json must define the npmScope property.");
    }
    return affected_apps_1.affectedApps(config.project.npmScope, projects, function (f) { return fs.readFileSync(f, 'utf-8'); }, touchedFiles);
}
exports.getAffectedApps = getAffectedApps;
function getTouchedProjects(touchedFiles) {
    var config = JSON.parse(fs.readFileSync('.angular-cli.json', 'utf-8'));
    var projects = getProjectNodes(config);
    if (!config.project.npmScope) {
        throw new Error(".angular-cli.json must define the npmScope property.");
    }
    return affected_apps_1.touchedProjects(projects, touchedFiles).filter(function (p) { return !!p; });
}
exports.getTouchedProjects = getTouchedProjects;
function getProjectRoots(projectNames) {
    var config = JSON.parse(fs.readFileSync('.angular-cli.json', 'utf-8'));
    var projects = getProjectNodes(config);
    return projectNames.map(function (name) {
        return path.dirname(projects.filter(function (p) { return p.name === name; })[0].root);
    });
}
exports.getProjectRoots = getProjectRoots;
function allFilesInDir(dirName) {
    var res = [];
    fs.readdirSync(dirName).forEach(function (c) {
        var child = path.join(dirName, c);
        try {
            if (!fs.statSync(child).isDirectory()) {
                res.push(normalizePath(child));
            }
            else if (fs.statSync(child).isDirectory()) {
                res = res.concat(allFilesInDir(child));
            }
        }
        catch (e) { }
    });
    return res;
}
function readDependencies(npmScope, projectNodes) {
    var m = lastModifiedAmongProjectFiles();
    if (!directoryExists('./dist')) {
        fs.mkdirSync('./dist');
    }
    if (!fileExists('./dist/nxdeps.json') || m > mtime('./dist/nxdeps.json')) {
        var deps = affected_apps_2.dependencies(npmScope, projectNodes, function (f) {
            return fs.readFileSync(f, 'UTF-8');
        });
        fs.writeFileSync('./dist/nxdeps.json', JSON.stringify(deps, null, 2), 'UTF-8');
        return deps;
    }
    else {
        return JSON.parse(fs.readFileSync('./dist/nxdeps.json', 'UTF-8'));
    }
}
exports.readDependencies = readDependencies;
function lastModifiedAmongProjectFiles() {
    return [
        recursiveMtime('libs'),
        recursiveMtime('apps'),
        mtime('.angular-cli.json'),
        mtime('tslint.json'),
        mtime('package.json')
    ].reduce(function (a, b) { return (a > b ? a : b); }, 0);
}
exports.lastModifiedAmongProjectFiles = lastModifiedAmongProjectFiles;
function recursiveMtime(dirName) {
    var res = mtime(dirName);
    fs.readdirSync(dirName).forEach(function (c) {
        var child = path.join(dirName, c);
        try {
            if (!fs.statSync(child).isDirectory()) {
                var c_1 = mtime(child);
                if (c_1 > res) {
                    res = c_1;
                }
            }
            else if (fs.statSync(child).isDirectory()) {
                var c_2 = recursiveMtime(child);
                if (c_2 > res) {
                    res = c_2;
                }
            }
        }
        catch (e) { }
    });
    return res;
}
function mtime(f) {
    return fs.fstatSync(fs.openSync(f, 'r')).mtime.getTime();
}
function normalizePath(file) {
    return file.split(path.sep).join('/');
}
function directoryExists(filePath) {
    try {
        return fs_1.statSync(filePath).isDirectory();
    }
    catch (err) {
        return false;
    }
}
function fileExists(filePath) {
    try {
        return fs_1.statSync(filePath).isFile();
    }
    catch (err) {
        return false;
    }
}
