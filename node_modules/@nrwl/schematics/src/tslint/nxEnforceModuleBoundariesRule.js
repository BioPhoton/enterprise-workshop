"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var Lint = require("tslint");
var fs_1 = require("fs");
var appRoot = require("app-root-path");
var shared_1 = require("../command-line/shared");
var affected_apps_1 = require("../command-line/affected-apps");
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule(options, projectPath, npmScope, projectNodes, deps) {
        var _this = _super.call(this, options) || this;
        _this.projectPath = projectPath;
        _this.npmScope = npmScope;
        _this.projectNodes = projectNodes;
        _this.deps = deps;
        if (!projectPath) {
            _this.projectPath = appRoot.path;
            if (!global.projectNodes) {
                var cliConfig = _this.readCliConfig(_this.projectPath);
                global.npmScope = cliConfig.project.npmScope;
                global.projectNodes = shared_1.getProjectNodes(cliConfig);
                global.deps = shared_1.readDependencies(global.npmScope, global.projectNodes);
            }
            _this.npmScope = global.npmScope;
            _this.projectNodes = global.projectNodes;
            _this.deps = global.deps;
        }
        return _this;
    }
    Rule.prototype.apply = function (sourceFile) {
        return this.applyWithWalker(new EnforceModuleBoundariesWalker(sourceFile, this.getOptions(), this.projectPath, this.npmScope, this.projectNodes, this.deps));
    };
    Rule.prototype.readCliConfig = function (projectPath) {
        return JSON.parse(fs_1.readFileSync(projectPath + "/.angular-cli.json", 'UTF-8'));
    };
    return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
var EnforceModuleBoundariesWalker = /** @class */ (function (_super) {
    __extends(EnforceModuleBoundariesWalker, _super);
    function EnforceModuleBoundariesWalker(sourceFile, options, projectPath, npmScope, projectNodes, deps) {
        var _this = _super.call(this, sourceFile, options) || this;
        _this.projectPath = projectPath;
        _this.npmScope = npmScope;
        _this.projectNodes = projectNodes;
        _this.deps = deps;
        _this.projectNodes.sort(function (a, b) {
            if (!a.name)
                return -1;
            if (!b.name)
                return -1;
            return a.name.length > b.name.length ? -1 : 1;
        });
        _this.allow = Array.isArray(_this.getOptions()[0].allow)
            ? _this.getOptions()[0].allow.map(function (a) { return "" + a; })
            : [];
        _this.depConstraints = Array.isArray(_this.getOptions()[0].depConstraints)
            ? _this.getOptions()[0].depConstraints
            : [];
        return _this;
    }
    EnforceModuleBoundariesWalker.prototype.visitImportDeclaration = function (node) {
        var imp = node.moduleSpecifier
            .getText()
            .substring(1, node.moduleSpecifier.getText().length - 1);
        // whitelisted import
        if (this.allow.indexOf(imp) > -1) {
            _super.prototype.visitImportDeclaration.call(this, node);
            return;
        }
        // check for relative and absolute imports
        if (this.isRelativeImportIntoAnotherProject(imp) ||
            this.isAbsoluteImportIntoAnotherProject(imp)) {
            this.addFailureAt(node.getStart(), node.getWidth(), "library imports must start with @" + this.npmScope + "/");
            return;
        }
        // check constraints between libs and apps
        if (imp.startsWith("@" + this.npmScope + "/")) {
            // we should find the name
            var sourceProject = this.findSourceProject();
            var targetProject = this.findProjectUsingImport(imp); // findProjectUsingImport to take care of same prefix
            // something went wrong => return.
            if (!sourceProject || !targetProject) {
                _super.prototype.visitImportDeclaration.call(this, node);
                return;
            }
            // check for circular dependency
            if (this.isCircular(sourceProject, targetProject)) {
                var error = "Circular dependency between \"" + sourceProject.name + "\" and \"" + targetProject.name + "\" detected";
                this.addFailureAt(node.getStart(), node.getWidth(), error);
                return;
            }
            // same project => allow
            if (sourceProject === targetProject) {
                _super.prototype.visitImportDeclaration.call(this, node);
                return;
            }
            // cannot import apps
            if (targetProject.type === affected_apps_1.ProjectType.app) {
                this.addFailureAt(node.getStart(), node.getWidth(), 'imports of apps are forbidden');
                return;
            }
            // deep imports aren't allowed
            if (imp !== "@" + this.npmScope + "/" + targetProject.name) {
                this.addFailureAt(node.getStart(), node.getWidth(), 'deep imports into libraries are forbidden');
                return;
            }
            // if we import a library using loadChildre, we should not import it using es6imports
            if (this.onlyLoadChildren(sourceProject.name, targetProject.name, [])) {
                this.addFailureAt(node.getStart(), node.getWidth(), 'imports of lazy-loaded libraries are forbidden');
                return;
            }
            // check that dependency constraints are satisfied
            if (this.depConstraints.length > 0) {
                var constraint = this.findConstraintFor(sourceProject);
                // when no constrains found => error. Force the user to provision them.
                if (!constraint) {
                    this.addFailureAt(node.getStart(), node.getWidth(), "A project without tags cannot depend on any libraries");
                    return;
                }
                if (hasNoneOfTheseTags(targetProject, constraint.onlyDependOnLibsWithTags || [])) {
                    var allowedTags = constraint.onlyDependOnLibsWithTags
                        .map(function (s) { return "\"" + s + "\""; })
                        .join(', ');
                    var error = "A project tagged with \"" + constraint.sourceTag + "\" can only depend on libs tagged with " + allowedTags;
                    this.addFailureAt(node.getStart(), node.getWidth(), error);
                    return;
                }
            }
        }
        _super.prototype.visitImportDeclaration.call(this, node);
    };
    EnforceModuleBoundariesWalker.prototype.isCircular = function (sourceProject, targetProject) {
        if (!this.deps[targetProject.name])
            return false;
        return this.deps[targetProject.name].some(function (dep) { return dep.projectName == sourceProject.name; });
    };
    EnforceModuleBoundariesWalker.prototype.onlyLoadChildren = function (sourceProjectName, targetProjectName, visited) {
        var _this = this;
        if (visited.indexOf(sourceProjectName) > -1)
            return false;
        return ((this.deps[sourceProjectName] || []).filter(function (d) {
            if (d.type !== affected_apps_1.DependencyType.loadChildren)
                return false;
            if (d.projectName === targetProjectName)
                return true;
            return _this.onlyLoadChildren(d.projectName, targetProjectName, visited.concat([
                sourceProjectName
            ]));
        }).length > 0);
    };
    EnforceModuleBoundariesWalker.prototype.isRelativeImportIntoAnotherProject = function (imp) {
        if (!this.isRelative(imp))
            return false;
        var targetFile = path
            .resolve(path.join(this.projectPath, path.dirname(this.getSourceFilePath())), imp)
            .split(path.sep)
            .join('/')
            .substring(this.projectPath.length + 1);
        var sourceProject = this.findSourceProject();
        var targetProject = this.findTargetProject(targetFile);
        return sourceProject && targetProject && sourceProject !== targetProject;
    };
    EnforceModuleBoundariesWalker.prototype.getSourceFilePath = function () {
        return this.getSourceFile().fileName.substring(this.projectPath.length + 1);
    };
    EnforceModuleBoundariesWalker.prototype.findSourceProject = function () {
        var targetFile = removeExt(this.getSourceFilePath());
        return this.findProjectUsingFile(targetFile);
    };
    EnforceModuleBoundariesWalker.prototype.findTargetProject = function (targetFile) {
        var targetProject = this.findProjectUsingFile(targetFile);
        if (!targetProject) {
            targetProject = this.findProjectUsingFile(path.join(targetFile, 'index'));
        }
        return targetProject;
    };
    EnforceModuleBoundariesWalker.prototype.findProjectUsingFile = function (file) {
        return this.projectNodes.filter(function (n) { return containsFile(n.files, file); })[0];
    };
    EnforceModuleBoundariesWalker.prototype.findProjectUsingImport = function (imp) {
        var unscopedImport = imp.substring(this.npmScope.length + 2);
        return this.projectNodes.filter(function (n) { return unscopedImport === n.name || unscopedImport.startsWith(n.name + "/"); })[0];
    };
    EnforceModuleBoundariesWalker.prototype.isAbsoluteImportIntoAnotherProject = function (imp) {
        return (imp.startsWith('libs/') ||
            imp.startsWith('/libs/') ||
            imp.startsWith('apps/') ||
            imp.startsWith('/apps/'));
    };
    EnforceModuleBoundariesWalker.prototype.isRelative = function (s) {
        return s.startsWith('.');
    };
    EnforceModuleBoundariesWalker.prototype.findConstraintFor = function (sourceProject) {
        return this.depConstraints.filter(function (f) {
            return hasTag(sourceProject, f.sourceTag);
        })[0];
    };
    return EnforceModuleBoundariesWalker;
}(Lint.RuleWalker));
function hasNoneOfTheseTags(proj, tags) {
    return tags.filter(function (allowedTag) { return hasTag(proj, allowedTag); }).length === 0;
}
function hasTag(proj, tag) {
    return (proj.tags || []).indexOf(tag) > -1 || tag === '*';
}
function containsFile(files, targetFileWithoutExtension) {
    return !!files.filter(function (f) { return removeExt(f) === targetFileWithoutExtension; })[0];
}
function removeExt(file) {
    return file.replace(/\.[^/.]+$/, '');
}
