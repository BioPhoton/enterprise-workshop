"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var nxEnforceModuleBoundariesRule_1 = require("./nxEnforceModuleBoundariesRule");
var affected_apps_1 = require("../command-line/affected-apps");
describe('Enforce Module Boundaries', function () {
    it('should not error when everything is in order', function () {
        var failures = runRule({ allow: ['@mycompany/mylib/deep'] }, process.cwd() + "/proj/apps/myapp/src/main.ts", "\n        import '@mycompany/mylib';\n        import '@mycompany/mylib/deep';\n        import '../blah';\n      ", [
            {
                name: 'myapp',
                root: 'libs/myapp/src',
                type: affected_apps_1.ProjectType.app,
                tags: [],
                files: ["apps/myapp/src/main.ts", "apps/myapp/blah.ts"]
            },
            {
                name: 'mylib',
                root: 'libs/mylib/src',
                type: affected_apps_1.ProjectType.lib,
                tags: [],
                files: ["libs/mylib/index.ts", "libs/mylib/deep.ts"]
            }
        ]);
        expect(failures.length).toEqual(0);
    });
    it('should handle multiple projects starting with the same prefix properly', function () {
        var failures = runRule({}, process.cwd() + "/proj/apps/myapp/src/main.ts", "\n        import '@mycompany/myapp2/mylib';\n      ", [
            {
                name: 'myapp',
                root: 'libs/myapp/src',
                type: affected_apps_1.ProjectType.app,
                tags: [],
                files: ["apps/myapp/src/main.ts", "apps/myapp/blah.ts"]
            },
            {
                name: 'myapp2',
                root: 'libs/myapp2/src',
                type: affected_apps_1.ProjectType.app,
                tags: [],
                files: []
            },
            {
                name: 'myapp2/mylib',
                root: 'libs/myapp2/mylib/src',
                type: affected_apps_1.ProjectType.lib,
                tags: [],
                files: ['libs/myapp2/mylib/src/index.ts']
            }
        ]);
        expect(failures.length).toEqual(0);
    });
    describe('depConstraints', function () {
        var projectNodes = [
            {
                name: 'api',
                root: 'libs/api/src',
                type: affected_apps_1.ProjectType.lib,
                tags: ['api'],
                files: ["libs/api/index.ts"]
            },
            {
                name: 'impl',
                root: 'libs/impl/src',
                type: affected_apps_1.ProjectType.lib,
                tags: ['impl'],
                files: ["libs/impl/index.ts"]
            },
            {
                name: 'impl2',
                root: 'libs/impl2/src',
                type: affected_apps_1.ProjectType.lib,
                tags: ['impl'],
                files: ["libs/impl2/index.ts"]
            },
            {
                name: 'untagged',
                root: 'libs/untagged/src',
                type: affected_apps_1.ProjectType.lib,
                tags: [],
                files: ["libs/untagged/index.ts"]
            }
        ];
        var depConstraints = {
            depConstraints: [
                { sourceTag: 'api', onlyDependOnLibsWithTags: ['api'] },
                { sourceTag: 'impl', onlyDependOnLibsWithTags: ['api', 'impl'] }
            ]
        };
        it('should error when the target library does not have the right tag', function () {
            var failures = runRule(depConstraints, process.cwd() + "/proj/libs/api/index.ts", "\n        import '@mycompany/impl';\n      ", projectNodes);
            expect(failures[0].getFailure()).toEqual('A project tagged with "api" can only depend on libs tagged with "api"');
        });
        it('should error when the target library is untagged', function () {
            var failures = runRule(depConstraints, process.cwd() + "/proj/libs/api/index.ts", "\n        import '@mycompany/untagged';\n      ", projectNodes);
            expect(failures[0].getFailure()).toEqual('A project tagged with "api" can only depend on libs tagged with "api"');
        });
        it('should error when the source library is untagged', function () {
            var failures = runRule(depConstraints, process.cwd() + "/proj/libs/untagged/index.ts", "\n        import '@mycompany/api';\n      ", projectNodes);
            expect(failures[0].getFailure()).toEqual('A project without tags cannot depend on any libraries');
        });
        it('should not error when the constraints are satisfied', function () {
            var failures = runRule(depConstraints, process.cwd() + "/proj/libs/impl/index.ts", "\n        import '@mycompany/impl2';\n      ", projectNodes);
            expect(failures.length).toEqual(0);
        });
        it('should support wild cards', function () {
            var failures = runRule({
                depConstraints: [{ sourceTag: '*', onlyDependOnLibsWithTags: ['*'] }]
            }, process.cwd() + "/proj/libs/api/index.ts", "\n        import '@mycompany/impl';\n      ", projectNodes);
            expect(failures.length).toEqual(0);
        });
    });
    describe('relative imports', function () {
        it('should not error when relatively importing the same library', function () {
            var failures = runRule({}, process.cwd() + "/proj/libs/mylib/src/main.ts", 'import "../other"', [
                {
                    name: 'mylib',
                    root: 'libs/mylib/src',
                    type: affected_apps_1.ProjectType.lib,
                    tags: [],
                    files: ["libs/mylib/src/main.ts", "libs/mylib/other.ts"]
                }
            ]);
            expect(failures.length).toEqual(0);
        });
        it('should not error when relatively importing the same library (index file)', function () {
            var failures = runRule({}, process.cwd() + "/proj/libs/mylib/src/main.ts", 'import "../other"', [
                {
                    name: 'mylib',
                    root: 'libs/mylib/src',
                    type: affected_apps_1.ProjectType.lib,
                    tags: [],
                    files: ["libs/mylib/src/main.ts", "libs/mylib/other/index.ts"]
                }
            ]);
            expect(failures.length).toEqual(0);
        });
        it('should error when relatively importing another library', function () {
            var failures = runRule({}, process.cwd() + "/proj/libs/mylib/src/main.ts", 'import "../../other"', [
                {
                    name: 'mylib',
                    root: 'libs/mylib/src',
                    type: affected_apps_1.ProjectType.lib,
                    tags: [],
                    files: ["libs/mylib/src/main.ts"]
                },
                {
                    name: 'other',
                    root: 'libs/other/src',
                    type: affected_apps_1.ProjectType.lib,
                    tags: [],
                    files: ['libs/other/index.ts']
                }
            ]);
            expect(failures[0].getFailure()).toEqual('library imports must start with @mycompany/');
        });
    });
    it('should error on absolute imports into libraries without using the npm scope', function () {
        var failures = runRule({}, process.cwd() + "/proj/libs/mylib/src/main.ts", 'import "libs/src/other.ts"', [
            {
                name: 'mylib',
                root: 'libs/mylib/src',
                type: affected_apps_1.ProjectType.lib,
                tags: [],
                files: ["libs/mylib/src/main.ts", "libs/mylib/src/other.ts"]
            }
        ]);
        expect(failures.length).toEqual(1);
        expect(failures[0].getFailure()).toEqual('library imports must start with @mycompany/');
    });
    it('should error about deep imports into libraries', function () {
        var failures = runRule({}, process.cwd() + "/proj/libs/mylib/src/main.ts", "\n      import \"@mycompany/other/blah\"\n      import \"@mycompany/other/sublib/blah\"\n      ", [
            {
                name: 'mylib',
                root: 'libs/mylib/src',
                type: affected_apps_1.ProjectType.lib,
                tags: [],
                files: ["libs/mylib/src/main.ts"]
            },
            {
                name: 'other',
                root: 'libs/other/src',
                type: affected_apps_1.ProjectType.lib,
                tags: [],
                files: ["libs/other/blah.ts"]
            },
            {
                name: 'other/sublib',
                root: 'libs/other/sublib/src',
                type: affected_apps_1.ProjectType.lib,
                tags: [],
                files: ["libs/other/sublib/blah.ts"]
            }
        ]);
        expect(failures[0].getFailure()).toEqual('deep imports into libraries are forbidden');
        expect(failures[1].getFailure()).toEqual('deep imports into libraries are forbidden');
    });
    it('should error on importing a lazy-loaded library', function () {
        var failures = runRule({}, process.cwd() + "/proj/libs/mylib/src/main.ts", 'import "@mycompany/other";', [
            {
                name: 'mylib',
                root: 'libs/mylib/src',
                type: affected_apps_1.ProjectType.lib,
                tags: [],
                files: ["libs/mylib/src/main.ts"]
            },
            {
                name: 'other',
                root: 'libs/other/src',
                type: affected_apps_1.ProjectType.lib,
                tags: [],
                files: ["libs/other/index.ts"]
            }
        ], {
            mylib: [{ projectName: 'other', type: affected_apps_1.DependencyType.loadChildren }]
        });
        expect(failures[0].getFailure()).toEqual('imports of lazy-loaded libraries are forbidden');
    });
    it('should error on importing an app', function () {
        var failures = runRule({}, process.cwd() + "/proj/libs/mylib/src/main.ts", 'import "@mycompany/myapp"', [
            {
                name: 'mylib',
                root: 'libs/mylib/src',
                type: affected_apps_1.ProjectType.lib,
                tags: [],
                files: ["libs/mylib/src/main.ts"]
            },
            {
                name: 'myapp',
                root: 'apps/myapp/src',
                type: affected_apps_1.ProjectType.app,
                tags: [],
                files: ["apps/myapp/index.ts"]
            }
        ]);
        expect(failures[0].getFailure()).toEqual('imports of apps are forbidden');
    });
    it('should error when circular dependency detected', function () {
        var failures = runRule({}, process.cwd() + "/proj/libs/anotherlib/src/main.ts", 'import "@mycompany/mylib"', [
            {
                name: 'mylib',
                root: 'libs/mylib/src',
                type: affected_apps_1.ProjectType.lib,
                tags: [],
                files: ["libs/mylib/src/main.ts"]
            },
            {
                name: 'anotherlib',
                root: 'libs/anotherlib/src',
                type: affected_apps_1.ProjectType.lib,
                tags: [],
                files: ["libs/anotherlib/src/main.ts"]
            },
            {
                name: 'myapp',
                root: 'apps/myapp/src',
                type: affected_apps_1.ProjectType.app,
                tags: [],
                files: ["apps/myapp/index.ts"]
            }
        ], {
            mylib: [{ projectName: 'anotherlib', type: affected_apps_1.DependencyType.es6Import }]
        });
        expect(failures[0].getFailure()).toEqual('Circular dependency between "anotherlib" and "mylib" detected');
    });
});
function runRule(ruleArguments, contentPath, content, projectNodes, deps) {
    if (deps === void 0) { deps = {}; }
    var options = {
        ruleArguments: [ruleArguments],
        ruleSeverity: 'error',
        ruleName: 'enforceModuleBoundaries'
    };
    var sourceFile = ts.createSourceFile(contentPath, content, ts.ScriptTarget.Latest, true);
    var rule = new nxEnforceModuleBoundariesRule_1.Rule(options, process.cwd() + "/proj", 'mycompany', projectNodes, deps);
    return rule.apply(sourceFile);
}
